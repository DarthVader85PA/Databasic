<?xml version="1.0"?>
<doc>
<assembly>
<name>
Databasic
</name>
</assembly>
<members>
<member name="T:Databasic.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:Databasic.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:Databasic.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="T:Databasic.ActiveRecord.Entity">
 <summary>
 Active record base class for database models.
 All properties and fields in class extended from this class should be 
 named in the same case sensitive way as columns are named in database.
 Choose fields and properties types to fit into database types.
 </summary>
</member>
<member name="F:Databasic.ActiveRecord.Entity.connectionIndex">
 <summary>
 
 </summary>
</member>
<member name="F:Databasic.ActiveRecord.Entity.connectionName">
 <summary>
 
 </summary>
</member>
<member name="F:Databasic.ActiveRecord.Entity.tableNames">
 <summary>
 ActiveRecord class database table name(s), first table is primary table.
 </summary>
</member>
<member name="F:Databasic.ActiveRecord.Entity.uniqueColumnName">
 <summary>
 ActiveRecord class primary database table unique column name, usually "Id".
 </summary>
</member>
<member name="F:Databasic.ActiveRecord.Entity.resource">
 <summary>
 
 </summary>
</member>
<member name="P:Databasic.ActiveRecord.Entity.Id">
 <summary>
 Active record model Id
 </summary>
</member>
<member name="F:Databasic.ActiveRecord.Entity.InitialSetUp">
 <summary>
 Internal switch for setuping values by methods .ToXxxxx() to not fill touched dictionary.
 </summary>
</member>
<member name="F:Databasic.ActiveRecord.Entity._initialData">
 <summary>
 Properties with values and fields with values touched by indexer.
 </summary>
</member>
<member name="F:Databasic.ActiveRecord.Entity._reserveStore">
 <summary>
 Reserve store to store anything what has been not specified by any property or field.
 </summary>
</member>
<member name="M:Databasic.ActiveRecord.Entity.#ctor">
 <summary>
 Empty constructor to create ActiveRecord instances by Activator.CreateInstance(typeof(TActiveRecord))
 </summary>
</member>
<member name="P:Databasic.ActiveRecord.Entity.Item(System.String)">
 <summary>
 Default member to get any model value by indexer.
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.get(System.String)">
 <summary>
 Get any property, field or reserve store record.
 </summary>
 <param name="key">Property, field or reserve store value name.</param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.set(System.String,System.Object)">
 <summary>
 Set any property, field or reserve store value.
 </summary>
 <param name="key">Property, field or reserve store key.</param>
 <param name="value">Property, field or reserve store value.</param>
</member>
<member name="M:Databasic.ActiveRecord.Entity.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
 <summary>
 Internal overloading method for DynamicObject.
 </summary>
 <param name="binder"></param>
 <param name="result"></param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
 <summary>
 Internal overloading method for DynamicObject.
 </summary>
 <param name="binder"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.setField(System.String,System.Object,System.Reflection.FieldInfo)">
 <summary>
 Set field setter method - called from indexer set block.
 </summary>
 <param name="key"></param>
 <param name="rawValue"></param>
 <param name="fieldInfo"></param>
</member>
<member name="M:Databasic.ActiveRecord.Entity.setProperty(System.String,System.Object,System.Reflection.PropertyInfo)">
 <summary>
 Set property setter method - called from indexer set block.
 </summary>
 <param name="key"></param>
 <param name="rawValue"></param>
 <param name="propertyInfo"></param>
</member>
<member name="M:Databasic.ActiveRecord.Entity.SetUp(System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean)">
 <summary>
 Set up all data from dictionary into instance properties or fields without touching.
 </summary>
 <param name="data">Dictionary with any values, named as instance fields and properties.</param>
 <param name="asInitialData">True to fill data into initial Dictionary to compare them later by GetTouched() function.</param>
</member>
<member name="M:Databasic.ActiveRecord.Entity.GetTouched">
 <summary>
 Get touched properties and fields in Dictionary. Everything what is different 
 to Me._initialData filled in instance initial set up.
 </summary>
 <returns>Dictionary with values, which are different from initial set up.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.Save(System.Int16)">
 <summary>
 Insert/Update ActiveRecord instance by non-existing/existing instance Id property (Id database column).
 </summary>
 <param name="connectionIndex">Config connection index to use different database, default by 0 to use first connection in &lt;connectionStrings&gt; list.</param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.Save(System.String)">
 <summary>
 Insert/Update ActiveRecord instance by non-existing/existing instance Id property (Id database column).
 </summary>
 <param name="connectionName">Config connection name to use different database, default by 0 to use first connection in &lt;connectionStrings&gt; list.</param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.Delete(System.Int16)">
 <summary>
 Delete ActiveRecord instance by instance Id property (Id database column).
 </summary>
 <param name="connectionIndex">Config connection index to use different database, default by 0 to use first connection in &lt;connectionStrings&gt; list.</param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.Delete(System.String)">
 <summary>
 Delete ActiveRecord instance by instance Id property (Id database column)
 </summary>
 <param name="connectionName">Config connection name to use different database, default by 0 to use first connection in &lt;connectionStrings&gt; list.</param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.TableName(System.Type,System.Int16)">
 <summary>
 Get declared table name by 'activeRecordType' and by optional called index argument.
 </summary>
 <param name="activeRecordType">Class type, inherited from ActiveRecord class with declared protected static field 'tables' as array of strings.</param>
 <param name="tableIndex">Array index to get proper table name string from declared protected static field 'tables' as array of strings.</param>
 <returns>Declared database table name from active record class.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.TableName``1(System.Int16)">
 <summary>
 Get declared table name from generic type 'TActiveRecord' and by optional called index argument.
 </summary>
 <typeparam name="TActiveRecord">Class name, inherited from ActiveRecord class with declared protected static field 'tables' as array of strings.</typeparam>
 <param name="tableIndex">Array index to get proper table name string from declared protected static field 'tables' as array of strings.</param>
 <returns>Declared database table name from active record class.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.UniqueColumn(System.Type)">
 <summary>
 Get declared identifier table column name by 'activeRecordType' argument.
 </summary>
 <param name="activeRecordType">Class type, inherited from ActiveRecord class with declared protected static field 'idColumn' as string.</param>
 <returns>Declared database table id column name from active record class.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.UniqueColumn``1">
 <summary>
 Get declared identifier table column name from generic type 'TActiveRecord'.
 </summary>
 <typeparam name="TActiveRecord">Class name, inherited from ActiveRecord class with declared protected static field 'idColumn' as string.</typeparam>
 <returns>Declared database table id column name from active record class.</returns>
</member>
<member name="F:Databasic.ActiveRecord.Resource.uniqueColumnName">
 <summary>
 Resource class primary database table unique column name, usually "Id".
 </summary>
</member>
<member name="M:Databasic.ActiveRecord.Resource.UniqueColumn(System.Type)">
 <summary>
 Get declared identifier table column name by 'resourceType' argument.
 </summary>
 <param name="resourceType">Class type, inherited from Resource class with declared protected static field 'idColumn' as string.</param>
 <returns>Declared database table id column name from resource class.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Resource.UniqueColumn``1">
 <summary>
 Get declared identifier table column name from generic type 'TResource'.
 </summary>
 <typeparam name="TResource">Class name, inherited from Resource class with declared protected static field 'idColumn' as string.</typeparam>
 <returns>Declared database table id column name from resource class.</returns>
</member>
<member name="F:Databasic.ActiveRecord.Resource.tableNames">
 <summary>
 Resource class database table name(s), first table is primary table.
 </summary>
</member>
<member name="M:Databasic.ActiveRecord.Resource.Table(System.Type,System.Int16)">
 <summary>
 Get declared table name by 'resourceType' and by optional called index argument.
 </summary>
 <param name="resourceType">Class type, inherited from Resource class with declared protected static field 'tables' as array of strings.</param>
 <param name="tableIndex">Array index to get proper table name string from declared protected override property 'tables' as array of strings.</param>
 <returns>Declared database table name from resource class.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Resource.Table``1(System.Int16)">
 <summary>
 Get declared table name from generic type 'TResource' and by optional called index argument.
 </summary>
 <typeparam name="TResource">Class name, inherited from Resource class with declared protected static field 'tables' as array of strings.</typeparam>
 <param name="tableIndex">Array index to get proper table name string from declared protected override property 'tables' as array of strings.</param>
 <returns>Declared database table name from resource class.</returns>
</member>
<member name="F:Databasic.ActiveRecord.Resource.connectionIndex">
 <summary>
 
 </summary>
</member>
<member name="F:Databasic.ActiveRecord.Resource.connectionName">
 <summary>
 
 </summary>
</member>
<member name="M:Databasic.ActiveRecord.Resource.#ctor">
 <summary>
 Empty constructor to create Resource instances by Activator.CreateInstance(typeof(TResource))
 </summary>
</member>
<member name="M:Databasic.ActiveRecord.Resource.#cctor">
 <summary>
 Static constructor to call static init in Connection class to load all configured connection 
 settings from (App|Web).config to be prepared for possible static function call Resource.Columns()
 </summary>
</member>
<member name="M:Databasic.Provider.Resource.GetById(Databasic.Connection,System.String,System.String,System.String,System.Object)">
 <summary>
 Get Databasic command instance to load single instance by unique identifier column, all table columns will be loaded by * SQL operator.
 </summary>
 <param name="connection">Database connection instance.</param>
 <param name="table">Database table name.</param>
 <param name="uniqueColumnName">Database table unique identifier column name.</param>
 <param name="uniqueColumnValue">Identifier value.</param>
 <returns></returns>
</member>
<member name="M:Databasic.Connection.BeginTransaction(System.String,Databasic.IsolationLevel)">
 <summary>
 Create and begin transaction on first config connection.
 </summary>
 <param name="transactionName">Transaction name.</param>
 <param name="isolationLevel">Transaction isolation level.</param>
 <returns>New transaction.</returns>
</member>
<member name="M:Databasic.Connection.BeginTransaction(System.Int16,System.String,Databasic.IsolationLevel)">
 <summary>
 Create and begin transaction on specified connection config index.
 </summary>
 <param name="connectionIndex">Config connection index.</param>
 <param name="transactionName">Transaction name.</param>
 <param name="isolationLevel">Transaction isolation level.</param>
 <returns>New transaction.</returns>
</member>
<member name="M:Databasic.Connection.BeginTransaction(System.String,System.String,Databasic.IsolationLevel)">
 <summary>
 Create and begin transaction on specified connection config name.
 </summary>
 <param name="connectionName">Config connection name.</param>
 <param name="transactionName">Transaction name.</param>
 <param name="isolationLevel">Transaction isolation level.</param>
 <returns>New transaction.</returns>
</member>
<member name="F:Databasic.Connection._config">
 <summary>
 Parsed subnode values from node &lt;connectionStrings&gt; in (App|Web).config file.
 </summary>
</member>
<member name="M:Databasic.Connection.Get(System.Int16)">
 <summary>
 Get and open connection by config index.
 </summary>
 <param name="connectionIndex">Config connection index.</param>
 <returns></returns>
</member>
<member name="M:Databasic.Connection.Get(System.String)">
 <summary>
 Get and open connection by config name.
 </summary>
 <param name="connectionName">Config connection name.</param>
 <returns></returns>
</member>
<member name="F:Databasic.Connection._closingLock">
 <summary>
 Threads semahore to read/write into managed connections store.
 </summary>
</member>
<member name="M:Databasic.Connection.Close">
 <summary>
 Close and drop all connections for current process and thread.
 Call this method always at thread end.
 </summary>
</member>
<member name="M:Databasic.Connection.Close(System.Int32)">
 <summary>
 Close and drop connection by config index for current process and thread.
 Call this method always after you have loaded all from any secondary database.
 </summary>
 <param name="connectionIndex">Config connection index.</param>
</member>
<member name="M:Databasic.Connection.Close(System.String)">
 <summary>
 Close and drop connection by config name for current process And thread.
 Call this method always after you have loaded all from any secondary database.
 </summary>
 <param name="connectionName">Config connection name.</param>
</member>
<member name="M:Databasic.Connection.Close(System.Int32,System.Int32,System.Int32)">
 <summary>
 Close and drop connection by config index for specificly called process and thread.
 Call this method only if you know what you are doing:-)
 </summary>
 <param name="connectionIndex">Config connection index.</param>
 <param name="processId">Specific process id.</param>
 <param name="threadId">Specific thread id.</param>
</member>
<member name="M:Databasic.Connection.CloseAllInProcess(System.Int32)">
 <summary>
 Close and drop connections for specificly called process.
 </summary>
</member>
<member name="F:Databasic.Connection.NamesAndIndexes">
 <summary>
 (App|Web).config connection names with their indexes.
 </summary>
</member>
<member name="F:Databasic.Connection.ClientName">
 <summary>
 Client assembly name used by specific connection implementation.
 </summary>
</member>
<member name="F:Databasic.Connection._staticInitLock">
 <summary>
 Threads semahore to read/write into managed connections store.
 </summary>
</member>
<member name="F:Databasic.Connection._initialized">
 <summary>
 True if static initialization completed, nothing else.
 </summary>
</member>
<member name="F:Databasic.Connection._supportedProviders">
 <summary>
 Supported database providers.
 </summary>
</member>
<member name="F:Databasic.Connection._connections">
 <summary>
 All Databasic connections managed store for all processes and for all threads.
 </summary>
</member>
<member name="M:Databasic.Connection._getProcessAndThreadKey">
 <summary>
 Return string as combination of current process id, underscore char and thread id.
 </summary>
 <returns>String as combination of current process id, underscore char and thread id.</returns>
</member>
<member name="M:Databasic.Connection.errorHandler(System.Object,System.EventArgs)">
 <summary>
 Fire all added error handlers.
 </summary>
 <param name="sender">Exception instance.</param>
 <param name="e">EventArgs instance.</param>
</member>
<member name="M:Databasic.Connection.#cctor">
 <summary>
 Load config and set up connection strings.
 </summary>
</member>
<member name="E:Databasic.Events.Error">
 <summary>
 Custom error handler to print or log any database error.
 </summary>
</member>
<member name="M:Databasic.Tools.GetTypeGlobaly(System.String)">
 <summary>
 Return Type object by sstring in forms: "Full.Class.Name" or "AssemblyName:Full.Class.Name"
 </summary>
 <param name="fullClassName" type="String">"Full.Class.Name" or "AssemblyName:Full.Class.Name"</param>
 <returns type="Type">Desired type</returns>
</member>
<member name="M:Databasic.Tools.GetTypeGlobaly(System.String,System.String)">
 <summary>
 Return Type object by two strings in form: "AssemblyName", "Full.Class.Name"
 </summary>
 <param name="assemblyName" type="String">"AssemblyName" for AssemblyName.dll</param>
 <param name="fullClassName" type="String">Full class name including namespace</param>
 <returns type="Type">Desired type</returns>
</member>
<member name="M:Databasic.Database.GetById``1(System.Object,System.Int16)">
 <summary>
 Get active record entity instance by unique column, all table columns will be loaded by * SQL operator if no columns defined.
 </summary>
 <typeparam name="TValue">Model class type, inherited from ActiveRecord.</typeparam>
 <param name="uniqueColumnValue">Id column value.</param>
 <param name="connectionIndex">Config connection index to use different database, default by 0 to use first connection in &lt;connectionStrings&gt; list.</param>
 <returns></returns>
</member>
<member name="M:Databasic.Database.GetById``1(System.Object,System.String)">
 <summary>
 Get active record entity instance by unique column, all table columns will be loaded by * SQL operator if no columns defined.
 </summary>
 <typeparam name="TValue">Model class type, inherited from ActiveRecord.</typeparam>
 <param name="uniqueColumnValue">Id column value.</param>
 <param name="connectionName">Config connection name to use different database, default by Database.DEFAUT_CONNECTION_INDEX to use first connection in &lt;connectionStrings&gt; list.</param>
 <returns></returns>
</member>
<member name="M:Databasic.Database.GetById``1(System.Object,Databasic.Connection)">
 <summary>
 Get active record entity instance by unique column, all table columns will be loaded by * SQL operator if no columns defined.
 </summary>
 <typeparam name="TValue">Model class type, inherited from ActiveRecord.</typeparam>
 <param name="uniqueColumnValue">Id column value.</param>
 <param name="connection">Connection intance.</param>
 <returns></returns>
</member>
<member name="M:Databasic.Core.Reader.ToValue``1(System.Data.Common.DbDataReader,System.Boolean)">
 <summary>
 Convert single row and single column select result into desired type specified by generic argument.
 </summary>
 <typeparam name="TValue">Result variable type.</typeparam>
 <returns>Retyped single row and single column select result.</returns>
</member>
<member name="M:Databasic.Core.Reader.ToInstance``1(System.Collections.Generic.Dictionary{System.String,System.Object})">
 <summary>
 Create new instance by generic type and set up all called dictionary keys into new instance properties or fields.
 </summary>
 <typeparam name="TActiveRecord">New instance type.</typeparam>
 <param name="data">Data with values for new instance properties and fields.</param>
 <returns>New instance by generic type with values by second param.</returns>
</member>
<member name="M:Databasic.Core.Reader.ToInstance``1(System.Data.Common.DbDataReader,System.Boolean)">
 <summary>
 Create new instance by generic type and set up all called reader columns with one row at minimal into new instance properties or fields.
 If reader has no rows, Nothing is returned.
 </summary>
 <typeparam name="TActiveRecord">New instance type.</typeparam>
 <param name="reader">Reader with values for new instance properties and fields</param>
 <param name="closeReaderAfterSetUp">Automaticly close reader after all.</param>
 <returns></returns>
</member>
<member name="M:Databasic.Core.Reader.ToList``1(System.Data.Common.DbDataReader,System.Boolean)">
 <summary>
 Create new Dictionary with instances by generic type and set up all called reader columns into new instances properties or fields.
 If reader has no rows, empty list is returned.
 </summary>
 <typeparam name="TActiveRecord">Result list item generic type.</typeparam>
 <param name="reader">Reader with values for new instance properties and fields</param>
 <param name="closeReaderAfterSetUp">Automaticly close reader after all.</param>
 <returns></returns>
</member>
<member name="M:Databasic.Core.Reader.ToDictionary``2(System.Data.Common.DbDataReader,System.String,System.Boolean,System.Boolean)">
 <summary>
 Create new Dictionary with keys by first generic type and instances (values) by second generic type 
 and set up all called reader columns into new instances properties or fields. By first param as string,
 specify which column from reader to use to complete dictionary keys.
 If reader has no rows, empty dictionary is returned.
 </summary>
 <typeparam name="TKey">Result dictionary generic type to complete dictionary keys.</typeparam>
 <typeparam name="TActiveRecord">Result dictionary generic type to complete dictionary values.</typeparam>
 <param name="reader">Reader with values for new instance properties and fields</param>
 <param name="keyColumnName">Reader column name to use to complete result dictionary keys.</param>
 <param name="throwExceptionInDuplicateKey">True to thrown Exception if any previous key will be founded by filling the result, false to overwrite any previous value.</param>
 <param name="closeReaderAfterSetUp">Automaticly close reader after all.</param>
 <returns>Dictionary with keys completed by second param for reader column name, values completed by reader columns with the same names as TActiveRecord type fields/properties.</returns>
</member>
<member name="M:Databasic.Core.Reader.ToDictionary``2(System.Data.Common.DbDataReader,System.Func{``1,``0},System.Boolean,System.Boolean)">
 <summary>
 Create new Dictionary with keys by first generic type and instances (values) by second generic type 
 and set up all called reader columns into new instances properties or fields. By first param as anonymous function,
 specify which field/property from active record instance to use to complete dictionary key for each item.
 If reader has no rows, empty dictionary is returned.
 </summary>
 <typeparam name="TKey">Result dictionary generic type to complete dictionary keys.</typeparam>
 <typeparam name="TActiveRecord">Result dictionary generic type to complete dictionary values.</typeparam>
 <param name="reader">Reader with values for new instance properties and fields</param>
 <param name="keySelector">Anonymous function accepting first argument as TActiveRecord instance and returning it's specific field/property value to complete Dictionary key.</param>
 <param name="throwExceptionInDuplicateKey">True to thrown Exception if any previous key will be founded by filling the result, false to overwrite any previous value.</param>
 <param name="closeReaderAfterSetUp">Automaticly close reader after all.</param>
 <returns>Dictionary with keys completed by second anonymous function, values completed by reader columns with the same names as TActiveRecord type fields/properties.</returns>
</member>
<member name="M:Databasic.Core.Reader._getReaderRowColumns(System.Data.Common.DbDataReader)">
 <summary>
 Get column names from reader as list of strings.
 </summary>
 <param name="reader"></param>
 <returns></returns>
</member>
<member name="M:Databasic.Core.Reader._readerRowToInstance(System.Data.Common.DbDataReader,System.Collections.Generic.List{System.String},Databasic.ActiveRecord.Entity@)">
 <summary>
 Set up current reader row columns into instance properties and fields.
 </summary>
 <param name="reader">DbDataReader with current row moved, where current row will be used to fill instance properties and fields.</param>
 <param name="columns">Columns in reader in proper order.</param>
 <param name="instance">Instance to fill.</param>
</member>
<member name="P:Databasic.Statement.Command">
 <summary>
 Currently prepared and executed SQL command.
 </summary>
</member>
<member name="P:Databasic.Statement.Reader">
 <summary>
 Currently executed data reader from SQL command.
 </summary>
</member>
<member name="M:Databasic.Statement.#ctor(System.String,System.Data.Common.DbConnection)">
 <summary>
 Empty SQL statement constructor.
 </summary>
 <param name="sql">SQL statement code.</param>
 <param name="connection">Connection instance.</param>
</member>
<member name="M:Databasic.Statement.#ctor(System.String,System.Data.Common.DbTransaction)">
 <summary>
 Empty SQL statement constructor.
 </summary>
 <param name="sql">SQL statement code.</param>
 <param name="transaction">SQL transaction instance with connection instance inside.</param>
</member>
<member name="M:Databasic.Statement.create(System.String,Databasic.Connection)">
 <summary>
 Create proper type of SQL statement by connection type.
 </summary>
 <param name="sql">SQL statement code.</param>
 <param name="connection">Connection instance.</param>
 <returns>New specificly typed SQL statement.</returns>
</member>
<member name="M:Databasic.Statement.create(System.String,Databasic.Transaction)">
 <summary>
 Create proper type of SQL statement by connection type.
 </summary>
 <param name="sql">SQL statement code.</param>
 <param name="transaction">SQL transaction instance with connection instance inside.</param>
 <returns>New specificly typed SQL statement.</returns>
</member>
<member name="M:Databasic.Statement.Prepare(System.String)">
 <summary>
 Create and prepare database SQL statement. Put '@' char before all param names in your SQL code.
 </summary>
 <param name="sql">SQL statement.</param>
 <returns>New specificly typed SQL statement by connection.</returns>
</member>
<member name="M:Databasic.Statement.Prepare(System.String,System.Int16)">
 <summary>
 Create and prepare database SQL statement. Put '@' char before all param names in your SQL code.
 </summary>
 <param name="sql">SQL code for statement. Put '@' char before all param names in your SQL code.</param>
 <param name="connectionIndex">
 Database connection index from App|Web.config to use specific database connection, 
 default value is 0 to use first connection settings subnode from &lt;connectionStrings&gt; config node.
 </param>
 <returns>New specificly typed SQL statement by connection.</returns>
</member>
<member name="M:Databasic.Statement.Prepare(System.String,System.String)">
 <summary>
 Create and prepare database SQL statement. Put '@' char before all param names in your SQL code.
 </summary>
 <param name="sql">SQL code for statement. Put '@' char before all param names in your SQL code.</param>
 Database connection name from App|Web.config to use specific database connection, 
 default value is 'DefaultConnection' to use default connection settings subnode from &lt;connectionStrings&gt; config node.
 <returns>New specificly typed SQL statement by connection.</returns>
</member>
<member name="M:Databasic.Statement.Prepare(System.String,Databasic.Connection)">
 <summary>
 Create and prepare database SQL statement. Put '@' char before all param names in your SQL code.
 </summary>
 <param name="sql">SQL code for statement. Put '@' char before all param names in your SQL code.</param>
 <param name="connection">Your specific database connection instance to execute this SQL statement inside.</param>
 <returns>New specificly typed SQL statement by connection.</returns>
</member>
<member name="M:Databasic.Statement.Prepare(System.String,Databasic.Transaction)">
 <summary>
 Create and prepare database SQL statement. Put '@' char before all param names in your SQL code.
 Created database statement will be executed in passed transaction.
 </summary>
 <param name="sql">SQL code for statement. Put '@' char before all param names in your SQL code.</param>
 <param name="transaction">Database transaction from current connection to execute this SQL statement inside.</param>
 <returns>New specificly typed SQL statement by connection.</returns>
</member>
<member name="M:Databasic.Statement.FetchOne">
 <summary>
 Execute SQL statement and open data reader to get only first single row from select statement result.
 </summary>
 <returns>SQL statement instance with opened data reader.</returns>
</member>
<member name="M:Databasic.Statement.FetchOne(System.Object)">
 <summary>
 Execute SQL statement and open data reader to get only first single row from select statement result.
 </summary>
 <param name="sqlParams">Anonymous object with named keys as SQL statement params without any '@' chars in object keys.</param>
 <returns>SQL statement instance with opened data reader.</returns>
</member>
<member name="M:Databasic.Statement.FetchOne(System.Collections.Generic.Dictionary{System.String,System.Object})">
 <summary>
 Execute SQL statement and open data reader to get only first single row from select statement result.
 </summary>
 <param name="sqlParams">Dictionary with named keys as SQL statement params without any '@' chars in dictionary keys.</param>
 <returns>SQL statement instance with opened data reader.</returns>
</member>
<member name="M:Databasic.Statement.FetchAll">
 <summary>
 Execute SQL statement and open data reader to get all rows from select statement result.
 </summary>
 <returns>SQL statement instance with opened data reader.</returns>
</member>
<member name="M:Databasic.Statement.FetchAll(Databasic.CommandBehavior)">
 <summary>
 Execute SQL statement and open data reader to get all rows from select statement result.
 </summary>
 <param name="commandBehavior">SQL data reader command behaviour, optional.</param>
 <returns>SQL statement instance with opened data reader.</returns>
</member>
<member name="M:Databasic.Statement.FetchAll(System.Object,Databasic.CommandBehavior)">
 <summary>
 Execute SQL statement and open data reader to get all rows from select statement result.
 </summary>
 <param name="sqlParams">Anonymous object with named keys as SQL statement params without any '@' chars in object keys.</param>
 <param name="commandBehavior">SQL data reader command behaviour, optional.</param>
 <returns>SQL statement instance with opened data reader.</returns>
</member>
<member name="M:Databasic.Statement.FetchAll(System.Collections.Generic.Dictionary{System.String,System.Object},Databasic.CommandBehavior)">
 <summary>
 Execute SQL statement and open data reader to get all rows from select statement result.
 </summary>
 <param name="sqlParams">Dictionary with named keys as SQL statement params without any '@' chars in dictionary keys.</param>
 <param name="commandBehavior">SQL data reader command behaviour, optional.</param>
 <returns>SQL statement instance with opened data reader.</returns>
</member>
<member name="M:Databasic.Statement.Exec">
 <summary>
 Execute any non select SQL statement and return affected rows count.
 </summary>
 <returns>Affected rows count.</returns>
</member>
<member name="M:Databasic.Statement.Exec(System.Object)">
 <summary>
 Execute any non select SQL statement and return affected rows count.
 </summary>
 <param name="sqlParams">Anonymous object with named keys as SQL statement params without any '@' chars in object keys.</param>
 <returns>Affected rows count.</returns>
</member>
<member name="M:Databasic.Statement.Exec(System.Collections.Generic.Dictionary{System.String,System.Object})">
 <summary>
 Execute any non select SQL statement and return affected rows count.
 </summary>
 <param name="sqlParams">Dictionary with named keys as SQL statement params without any '@' chars in dictionary keys.</param>
 <returns>Affected rows count.</returns>
</member>
<member name="M:Databasic.Statement.ToValue``1">
 <summary>
 Create desired variable type from single row and single column select result.
 Specify result variable type by generic argument.
 </summary>
 <typeparam name="TValue">Result result variable type.</typeparam>
 <returns>Retyped single row and single column select result.</returns>
</member>
<member name="M:Databasic.Statement.ToInstance``1">
 <summary>
 Create desired class instance type from single row and multicolumn column select result.
 Specify result class instance type by generic argument.
 </summary>
 <typeparam name="TActiveRecord">New result class instance type.</typeparam>
 <returns>New instance by generic type with values by generic argument.</returns>
</member>
<member name="M:Databasic.Statement.ToList``1">
 <summary>
 Create List of desired class instance types or List of variables from singlerow 
 or multirow and single column or multi column select result.
 Specify result class instance type or result variable type by generic argument.
 If reader has no rows, empty list is returned.
 </summary>
 <typeparam name="TActiveRecord">Result List item generic type.</typeparam>
 <returns>List of new instances/variables by generic type with values by generic argument.</returns>
</member>
<member name="M:Databasic.Statement.ToDictionary``2(System.String,System.Boolean)">
 <summary>
 Create Dictionary of values by desired class instance types or Dictionary of values by variables 
 from singlerow or multirow and single column or multi column select result. 
 Specify result Dictionary key type by first generic argument.
 Specify result Dictionary value class instance type or result Dictionary value variable type by second generic argument.
 Specify which column from select result to use to complete dictionary keys by first string param.
 If reader has no rows, empty Dictionary is returned.
 </summary>
 <typeparam name="TKey">Result Dictionary generic type to complete Dictionary keys.</typeparam>
 <typeparam name="TActiveRecord">Result Dictionary generic type to complete Dictionary values.</typeparam>
 <param name="keyColumnName">Reader column name to use to complete result dictionary keys.</param>
 <param name="throwExceptionInDuplicateKey">True to thrown Exception if any previous key will be founded by completing the result Dictionary, False to overwrite any previous value in Dictionary, True by default.</param>
 <returns>Dictionary of new instances/variables by generic type with values by generic argument.</returns>
</member>
<member name="M:Databasic.Statement.ToDictionary``2(System.Func{``1,``0},System.Boolean,System.Boolean)">
 <summary>
 Create new Dictionary with keys by first generic type and instances (values) by second generic type 
 and set up all called reader columns into new instances properties or fields. By first param as anonymous function,
 specify which field/property from active record instance to use to complete dictionary key for each item.
 If reader has no rows, empty dictionary is returned.
 </summary>
 <typeparam name="TKey">Result dictionary generic type to complete dictionary keys.</typeparam>
 <typeparam name="TActiveRecord">Result dictionary generic type to complete dictionary values.</typeparam>
 <param name="keySelector">Anonymous function accepting first argument as TActiveRecord instance and returning it's specific field/property value to complete Dictionary key.</param>
 <param name="throwExceptionInDuplicateKey">True to thrown Exception if any previous key will be founded by filling the result, false to overwrite any previous value.</param>
 <param name="closeReaderAfterSetUp">Automaticly close reader after all.</param>
 <returns>Dictionary with keys completed by second anonymous function, values completed by reader columns with the same names as TActiveRecord type fields/properties.</returns>
</member>
<member name="M:Databasic.Statement.addParamsWithValue(System.Object)">
 <summary>
 Set up all sql params into internal Command instance.
 </summary>
 <param name="sqlParams">Anonymous object with named keys as SQL statement params without any '@' chars in object keys.</param>
</member>
<member name="M:Databasic.Statement.addParamsWithValue(System.Collections.Generic.Dictionary{System.String,System.Object})">
 <summary>
 Set up all sql params into internal Command instance.
 </summary>
 <param name="sqlParams">Dictionary with named keys as SQL statement params without any '@' chars in dictionary keys.</param>
</member>
</members>
</doc>
